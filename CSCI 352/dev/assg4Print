%!PS-Adobe-3.0
%%Title: arg_parse.c, builtin.c, expand.c, msh.c, proto.h, ASSG4, Makefile, testScript
%%For: Zachary Quinn Evans
%%Creator: a2ps version 4.14
%%CreationDate: Fri May  9 02:03:32 2014
%%BoundingBox: 24 24 588 768
%%DocumentData: Clean7Bit
%%Orientation: Landscape
%%Pages: 14
%%PageOrder: Ascend
%%DocumentMedia: Letter 612 792 0 () ()
%%DocumentNeededResources: font Courier
%%+ font Courier-Bold
%%+ font Courier-BoldOblique
%%+ font Courier-Oblique
%%+ font Helvetica
%%+ font Helvetica-Bold
%%+ font Symbol
%%+ font Times-Bold
%%+ font Times-Roman
%%DocumentProcessColors: Black 
%%DocumentSuppliedResources: procset a2ps-a2ps-hdr
%%+ procset a2ps-black+white-Prolog
%%+ encoding ISO-8859-1Encoding
%%EndComments
/a2psdict 200 dict def
a2psdict begin
%%BeginProlog
%%Copyright: (c) 1988, 89, 90, 91, 92, 93 Miguel Santana
%%Copyright: (c) 1995, 96, 97, 98 Akim Demaille, Miguel Santana
% Check PostScript language level.
/languagelevel where {
  pop /gs_languagelevel languagelevel def
} {
  /gs_languagelevel 1 def
} ifelse

% EPSF import as in the Red Book
/BeginInclude {
  /b4_Inc_state save def    		% Save state for cleanup
  /dict_count countdictstack def	% Count objects on dict stack
  /op_count count 1 sub def		% Count objects on operand stack 
  userdict begin
    0 setgray 0 setlinecap
    1 setlinewidth 0 setlinejoin
    10 setmiterlimit [ ] 0 setdash newpath
    gs_languagelevel 1 ne {
      false setstrokeadjust false setoverprint 
    } if
} bind def

/EndInclude {
  count op_count sub { pos } repeat	% Clean up stacks
  countdictstack dict_count sub { end } repeat
  b4_Inc_state restore
} bind def

/BeginEPSF {
  BeginInclude
  /showpage { } def
} bind def

/EndEPSF {
  EndInclude
} bind def

% Page prefeed
/page_prefeed {         % bool -> -
  statusdict /prefeed known {
    statusdict exch /prefeed exch put
  } {
    pop
  } ifelse
} bind def

/deffont {
  findfont exch scalefont def
} bind def

/reencode_font {
  findfont reencode 2 copy definefont pop def
} bind def

% Function c-show (str => -)
% centers text only according to x axis.
/c-show { 
  dup stringwidth pop
  2 div neg 0 rmoveto
  show
} bind def

% Function l-show (str => -)
% prints texts so that it ends at currentpoint
/l-show {
  dup stringwidth pop neg 
  0 
  rmoveto show
} bind def

% center-fit show (str w => -)
% show centered, and scale currentfont so that the width is less than w
/cfshow {
  exch dup stringwidth pop
  % If the title is too big, try to make it smaller
  3 2 roll 2 copy
  gt
  { % if, i.e. too big
    exch div
    currentfont exch scalefont setfont
  } { % ifelse
    pop pop 
  }
  ifelse
  c-show			% center title
} bind def

% Return the y size of the current font
% - => fontsize
/currentfontsize {
  currentfont /FontType get 0 eq {
    currentfont /FontMatrix get 3 get
  }{
    currentfont /FontMatrix get 3 get 1000 mul
  } ifelse
} bind def

% reencode the font
% <encoding-vector> <fontdict> -> <newfontdict>
/reencode { %def
  dup length 5 add dict begin
    { %forall
      % <vector> <key> <val>
      1 index /FID ne 
      { def }{ pop pop } ifelse
    } forall
    /Encoding exch def % -

    % Use the font's bounding box to determine the ascent, descent,
    % and overall height; don't forget that these values have to be
    % transformed using the font's matrix.
    % We use `load' because sometimes BBox is executable, sometimes not.
    % Since we need 4 numbers an not an array avoid BBox from being executed
    /FontBBox load aload pop
    FontMatrix transform /Ascent exch def pop
    FontMatrix transform /Descent exch def pop
    /FontHeight Ascent Descent sub def

    % Get the underline position and thickness if they're defined.
    % Use 1 if they are not defined.
    currentdict /FontInfo 2 copy known
    { get
      /UnderlinePosition 2 copy % <FontInfo> /UP <FontInfo> /UP
      2 copy known
      { get }{ pop pop 1 } ifelse
      0 exch FontMatrix transform exch pop
      def % <FontInfo>

      /UnderlineThickness 2 copy % <FontInfo> /UT <FontInfo> /UT
      2 copy known
      { get }{ pop pop 1 } ifelse
      0 exch FontMatrix transform exch pop
      def % <FontInfo>
      pop % -
    }{ pop pop
    } ifelse

    currentdict
  end 
} bind def

% composite fonts for ASCII-EUC mixed strings
% Version 1.2 1/31/1990
% Original Ken'ichi HANDA (handa@etl.go.jp)
% Modified Norio Katayama (katayama@rd.nacsis.ac.jp),1998
% Extend & Fix Koji Nakamaru (maru@on.cs.keio.ac.jp), 1999
% Anyone can freely copy, modify, distribute this program.

/copyfont {	% font-dic extra-entry-count  copyfont  font-dic
	1 index maxlength add dict begin
	{	1 index /FID ne 2 index /UniqueID ne and
		{def} {pop pop} ifelse
	} forall
	currentdict
	end
} bind def

/compositefont { % ASCIIFontName EUCFontName RomanScale RomanOffset Rot(T/F) compositefont font
    /RomanRotation exch def
    /RomanOffset exch def
    /RomanScale exch def
    userdict /fixeucfont_dict known not {
	userdict begin
	    /fixeucfont_dict 2 dict begin
		/UpperByteEncoding [
		    16#00 1 16#20 { pop 0 } for
		    16#21 1 16#28 { 16#20 sub } for
		    16#29 1 16#2F { pop 0 } for
		    16#30 1 16#74 { 16#27 sub } for
		    16#75 1 16#FF { pop 0 } for
		] def
	        /LowerByteEncoding [
		    16#00 1 16#A0 { pop /.notdef } for
		    16#A1 1 16#FE { 16#80 sub 16 2 string cvrs
				    (cXX) dup 1 4 -1 roll
				    putinterval cvn } for
		    /.notdef
		] def
		currentdict
	    end def
	end
    } if
    findfont dup /FontType get 0 eq {
	14 dict begin
	    %
	    % 7+8 bit EUC font
	    %
	    12 dict begin
		/EUCFont exch def
		/FontInfo (7+8 bit EUC font) readonly def
		/PaintType 0 def
		/FontType 0 def
		/FontMatrix matrix def
		% /FontName
		/Encoding fixeucfont_dict /UpperByteEncoding get def
		/FMapType 2 def
		EUCFont /WMode known
		{ EUCFont /WMode get /WMode exch def }
		{ /WMode 0 def } ifelse
		/FDepVector [
		    EUCFont /FDepVector get 0 get
		    [ 16#21 1 16#28 {} for 16#30 1 16#74 {} for ]
		    {
			13 dict begin
			    /EUCFont EUCFont def
			    /UpperByte exch 16#80 add def	
			    % /FontName
			    /FontInfo (EUC lower byte font) readonly def
			    /PaintType 0 def
			    /FontType 3 def
			    /FontMatrix matrix def
			    /FontBBox {0 0 0 0} def
			    /Encoding
				fixeucfont_dict /LowerByteEncoding get def
			    % /UniqueID
			    % /WMode
			    /BuildChar {
				gsave
				exch dup /EUCFont get setfont
				/UpperByte get
				2 string
				dup 0 4 -1 roll put
				dup 1 4 -1 roll put
				dup stringwidth setcharwidth
				0 0 moveto show
				grestore
			    } bind def
			    currentdict
			end
			/lowerbytefont exch definefont
		    } forall
		] def
		currentdict
	    end
	    /eucfont exch definefont
	    exch
	    findfont 1 copyfont dup begin
		RomanRotation {
			/FontMatrix FontMatrix
			[ 0 RomanScale neg RomanScale 0 RomanOffset neg 0 ]
			matrix concatmatrix def
		}{
			/FontMatrix FontMatrix
			[ RomanScale 0 0 RomanScale 0 RomanOffset ] matrix concatmatrix
			def
			/CDevProc
			    {pop pop pop pop 0 exch -1000 exch 2 div 880} def
		} ifelse
	    end
	    /asciifont exch definefont
	    exch
	    /FDepVector [ 4 2 roll ] def
	    /FontType 0 def
	    /WMode 0 def
	    /FMapType 4 def
	    /FontMatrix matrix def
	    /Encoding [0 1] def
	    /FontBBox {0 0 0 0} def
%	    /FontHeight 1.0 def % XXXX
	    /FontHeight RomanScale 1.0 ge { RomanScale }{ 1.0 } ifelse def
	    /Descent -0.3 def   % XXXX
	    currentdict
	end
	/tmpfont exch definefont
	pop
	/tmpfont findfont
    }{
	pop findfont 0 copyfont
    } ifelse
} def	

/slantfont {	% FontName slant-degree  slantfont  font'
    exch findfont 1 copyfont begin
    [ 1 0 4 -1 roll 1 0 0 ] FontMatrix exch matrix concatmatrix
    /FontMatrix exch def
    currentdict
    end
} def

% Function print line number (<string> # -)
/# {
  gsave
    sx cw mul neg 2 div 0 rmoveto
    f# setfont
    c-show
  grestore
} bind def

% -------- Some routines to enlight plain b/w printings ---------

% Underline
% width --
/dounderline {
  currentpoint
  gsave
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    0 rlineto
    stroke
  grestore
} bind def

% Underline a string
% string --
/dounderlinestring {
  stringwidth pop
  dounderline
} bind def

/UL {
  /ul exch store
} bind def

% Draw a box of WIDTH wrt current font
% width --
/dobox {
  currentpoint
  gsave
    newpath
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    dup 0 rlineto
    0 currentfont /FontHeight get currentfontsize mul rlineto
    neg 0 rlineto
    closepath
    stroke
  grestore
} bind def

/BX {
  /bx exch store
} bind def

% Box a string
% string --
/doboxstring {
  stringwidth pop
  dobox
} bind def

%
% ------------- Color routines ---------------
%
/FG /setrgbcolor load def

% Draw the background
% width --
/dobackground {
  currentpoint
  gsave
    newpath
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    dup 0 rlineto
    0 currentfont /FontHeight get currentfontsize mul rlineto
    neg 0 rlineto
    closepath
    bgcolor aload pop setrgbcolor
    fill
  grestore
} bind def

% Draw bg for a string
% string --
/dobackgroundstring {
  stringwidth pop
  dobackground
} bind def


/BG {
  dup /bg exch store
  { mark 4 1 roll ] /bgcolor exch store } if
} bind def


/Show {
  bg { dup dobackgroundstring } if
  ul { dup dounderlinestring } if
  bx { dup doboxstring } if
  show
} bind def

% Function T(ab), jumps to the n-th tabulation in the current line
/T {
  cw mul x0 add
  bg { dup currentpoint pop sub dobackground } if
  ul { dup currentpoint pop sub dounderline } if
  bx { dup currentpoint pop sub dobox } if
  y0 moveto
} bind def

% Function n: move to the next line
/n {
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

% Function N: show and move to the next line
/N {
  Show
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

/S {
  Show
} bind def

%%BeginResource: procset a2ps-a2ps-hdr 2.0 2
%%Copyright: (c) 1988, 89, 90, 91, 92, 93 Miguel Santana
%%Copyright: (c) 1995, 96, 97, 98 Akim Demaille, Miguel Santana
% Function title: prints page header.
% <ct> <rt> <lt> are passed as argument
/title { 
  % 1. Draw the background
  x v get y v get moveto
  gsave
    0 th 2 div neg rmoveto 
    th setlinewidth
    0.95 setgray
    pw 0 rlineto stroke
  grestore
  % 2. Border it
  gsave
    0.7 setlinewidth
    pw 0 rlineto
    0 th neg rlineto
    pw neg 0 rlineto
    closepath stroke
  grestore
  % stk: ct rt lt
  x v get y v get th sub 1 add moveto
%%IncludeResource: font Helvetica
  fHelvetica fnfs 0.8 mul scalefont setfont
  % 3. The left title
  gsave
    dup stringwidth pop fnfs 0.8 mul add exch % leave space took on stack
    fnfs 0.8 mul hm rmoveto
    show			% left title
  grestore
  exch
  % stk: ct ltw rt
  % 4. the right title
  gsave
    dup stringwidth pop fnfs 0.8 mul add exch % leave space took on stack
    dup
    pw exch stringwidth pop fnfs 0.8 mul add sub
    hm
    rmoveto
    show			% right title
  grestore
  % stk: ct ltw rtw
  % 5. the center title
  gsave
    pw 3 1 roll
    % stk: ct pw ltw rtw
    3 copy 
    % Move to the center of the left room
    sub add 2 div hm rmoveto
    % What is the available space in here?
    add sub fnfs 0.8 mul sub fnfs 0.8 mul sub
    % stk: ct space_left
%%IncludeResource: font Helvetica-Bold
  fHelvetica-Bold fnfs scalefont setfont
    cfshow
  grestore
} bind def

% Function border: prints virtual page border
/border { %def
  gsave				% print four sides
    0 setgray
    x v get y v get moveto
    0.7 setlinewidth		% of the square
    pw 0 rlineto
    0 ph neg rlineto
    pw neg 0 rlineto
    closepath stroke
  grestore
} bind def

% Function water: prints a water mark in background
/water { %def
  gsave
    scx scy moveto rotate
%%IncludeResource: font Times-Bold
  fTimes-Bold 100 scalefont setfont
    .97 setgray
    dup stringwidth pop 2 div neg -50 rmoveto
    show
  grestore
} bind def

% Function rhead: prints the right header
/rhead {  %def
  lx ly moveto
  fHelvetica fnfs 0.8 mul scalefont setfont
  l-show
} bind def

% Function footer (cf rf lf -> -)
/footer {
  fHelvetica fnfs 0.8 mul scalefont setfont
  dx dy moveto
  show

  snx sny moveto
  l-show
  
  fnx fny moveto
  c-show
} bind def
%%EndResource
%%BeginResource: procset a2ps-black+white-Prolog 2.0 1

% Function T(ab), jumps to the n-th tabulation in the current line
/T { 
  cw mul x0 add y0 moveto
} bind def

% Function n: move to the next line
/n { %def
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

% Function N: show and move to the next line
/N {
  Show
  /y0 y0 bfs sub store
  x0 y0 moveto
}  bind def

/S {
  Show
} bind def

/p {
  false UL
  false BX
  fCourier bfs scalefont setfont
  Show
} bind def

/sy {
  false UL
  false BX
  fSymbol bfs scalefont setfont
  Show
} bind def

/k {
  false UL
  false BX
  fCourier-Oblique bfs scalefont setfont
  Show
} bind def

/K {
  false UL
  false BX
  fCourier-Bold bfs scalefont setfont
  Show
} bind def

/c {
  false UL
  false BX
  fCourier-Oblique bfs scalefont setfont
  Show
} bind def

/C {
  false UL
  false BX
  fCourier-BoldOblique bfs scalefont setfont
  Show 
} bind def

/l {
  false UL
  false BX
  fHelvetica bfs scalefont setfont
  Show
} bind def

/L {
  false UL
  false BX
  fHelvetica-Bold bfs scalefont setfont
  Show 
} bind def

/str{
  false UL
  false BX
  fTimes-Roman bfs scalefont setfont
  Show
} bind def

/e{
  false UL
  true BX
  fHelvetica-Bold bfs scalefont setfont
  Show
} bind def

%%EndResource
%%EndProlog
%%BeginSetup
%%IncludeResource: font Courier
%%IncludeResource: font Courier-Oblique
%%IncludeResource: font Courier-Bold
%%IncludeResource: font Times-Roman
%%IncludeResource: font Symbol
%%IncludeResource: font Courier-BoldOblique
%%BeginResource: encoding ISO-8859-1Encoding
/ISO-8859-1Encoding [
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/space /exclam /quotedbl /numbersign /dollar /percent /ampersand /quoteright 
/parenleft /parenright /asterisk /plus /comma /minus /period /slash 
/zero /one /two /three /four /five /six /seven 
/eight /nine /colon /semicolon /less /equal /greater /question 
/at /A /B /C /D /E /F /G 
/H /I /J /K /L /M /N /O 
/P /Q /R /S /T /U /V /W 
/X /Y /Z /bracketleft /backslash /bracketright /asciicircum /underscore 
/quoteleft /a /b /c /d /e /f /g 
/h /i /j /k /l /m /n /o 
/p /q /r /s /t /u /v /w 
/x /y /z /braceleft /bar /braceright /asciitilde /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/space /exclamdown /cent /sterling /currency /yen /brokenbar /section 
/dieresis /copyright /ordfeminine /guillemotleft /logicalnot /hyphen /registered /macron 
/degree /plusminus /twosuperior /threesuperior /acute /mu /paragraph /bullet 
/cedilla /onesuperior /ordmasculine /guillemotright /onequarter /onehalf /threequarters /questiondown 
/Agrave /Aacute /Acircumflex /Atilde /Adieresis /Aring /AE /Ccedilla 
/Egrave /Eacute /Ecircumflex /Edieresis /Igrave /Iacute /Icircumflex /Idieresis 
/Eth /Ntilde /Ograve /Oacute /Ocircumflex /Otilde /Odieresis /multiply 
/Oslash /Ugrave /Uacute /Ucircumflex /Udieresis /Yacute /Thorn /germandbls 
/agrave /aacute /acircumflex /atilde /adieresis /aring /ae /ccedilla 
/egrave /eacute /ecircumflex /edieresis /igrave /iacute /icircumflex /idieresis 
/eth /ntilde /ograve /oacute /ocircumflex /otilde /odieresis /divide 
/oslash /ugrave /uacute /ucircumflex /udieresis /yacute /thorn /ydieresis 
] def
%%EndResource
% Initialize page description variables.
/sh 612 def
/sw 792 def
/llx 24 def
/urx 768 def
/ury 588 def
/lly 24 def
/#copies 1 def
/th 15.000000 def
/fnfs 11 def
/bfs 7.493857 def
/cw 4.496314 def

% Dictionary for ISO-8859-1 support
/iso1dict 8 dict begin
  /fCourier ISO-8859-1Encoding /Courier reencode_font
  /fCourier-Bold ISO-8859-1Encoding /Courier-Bold reencode_font
  /fCourier-BoldOblique ISO-8859-1Encoding /Courier-BoldOblique reencode_font
  /fCourier-Oblique ISO-8859-1Encoding /Courier-Oblique reencode_font
  /fHelvetica ISO-8859-1Encoding /Helvetica reencode_font
  /fHelvetica-Bold ISO-8859-1Encoding /Helvetica-Bold reencode_font
  /fTimes-Bold ISO-8859-1Encoding /Times-Bold reencode_font
  /fTimes-Roman ISO-8859-1Encoding /Times-Roman reencode_font
currentdict end def
/bgcolor [ 0 0 0 ] def
/bg false def
/ul false def
/bx false def
% The font for line numbering
/f# /Helvetica findfont bfs .6 mul scalefont def
/fSymbol /Symbol findfont def
/hm fnfs 0.25 mul def
/pw
   cw 81.400000 mul
def
/ph
   522.321860 th add
def
/pmw urx llx sub pw 2 mul sub 1 div def
/pmh 0 def
/v 0 def
/x [
  0
  dup pmw add pw add
] def
/y [
  pmh ph add 0 mul ph add
  dup
] def
/scx sw 2 div def
/scy sh 2 div def
/snx urx def
/sny lly 2 add def
/dx llx def
/dy sny def
/fnx scx def
/fny dy def
/lx snx def
/ly ury fnfs 0.8 mul sub def
/sx 0 def
/tab 8 def
/x0 0 def
/y0 0 def
%%EndSetup

%%Page: (1-2) 1
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* CS 352 -- Argument parsing function) c n
( *  $Id: arg_parse.c,v 1.2 2014/04/22 02:08:08 evansz2 Exp $) N
( *  Zach Evans) N
( *  CSCI 352) N
( *  Spring 2014) N
( */) N
() p n
() N
(#include) K
( ") p
(proto.h) str
(") p n
(#include) K
( <stdio.h>) p n
(#include) K
( <string.h>) p n
(#include) K
( <unistd.h>) p n
(#include) K
( <errno.h>) p n
(#include) K
( <stdlib.h>) p n
(#include) K
( <sys/types.h>) p n
(#include) K
( <sys/wait.h>) p n
() N
() N
(int) k
( arg_parse \() p
(char) k
( *line, ) p
(char) k
( ***argvp\){) p n
(  ) S
(int) k
( argCount = 0; ) p
(//Number of arguments in the line) c n
(  ) p
(//int inArg = 0; //Flag to check if parser is in argument) c n
(  ) p
(//int inQuote = 0;) c n
(  ) p
(char) k
( *ptr = line; ) p
(//Pointer to traverse the arguments) c n
(  ) p
(char) k
( c; ) p
(//Character to be filled in with argument traversal) c n
(  ) p
(int) k
( idx = 0; ) p
(//Index in malloc'ed area) c n
(  ) p
(int) k
( state = 0;) p n
(  ) S
(/*) c n
(  States:) N
(  0: out of argument) N
(  1: argument starts with quote \(not used in counting args\)) N
(  2: in an argument) N
(  3: in a quote) N
(  4: checking for null argument) N
(  */) N
() p n
(  ) S
(while) K
( \(\(c = *ptr\) != 0\){ ) p
(//Count arguments) c n
(    ) p
(if) K
( \(state == 0\){) p n
(      ) S
(if) K
( \(c == ') p
(") str
('\){) p n
(        argCount++;) N
(        state = 3;) N
(      }) N
(      ) S
(else) K
( ) p
(if) K
(\(c !=') p
( ) str
('\){) p n
(        argCount++;) N
(        state = 2;) N
(      }) N
(    }) N
(    ) S
(else) K
( ) p
(if) K
(\(state == 2\){) p n
(      ) S
(if) K
( \(c == ') p
(") str
('\){) p n
(        state = 3;) N
(      }) N
(      ) S
(else) K
( ) p
(if) K
(\(c == ') p
( ) str
('\){) p n
(        state = 0;) N
(      }) N
(    }) N
(    ) S
(else) K
( ) p
(if) K
(\(state == 3\){) p n
(      ) S
(if) K
(\(c == ') p
(") str
('\){) p n
(        state = 2;) N
(      }) N
(    }) N
(    ptr++;) N
(  }) N
() N
(  ) S
(if) K
( \(state == 3\){ ) p
(//Odd number of quotes found) c n
(    dprintf\(1, ") p
(Odd number of quotes found in line\\n) str
("\);) p n
(    ) S
(return) K
( -1;) p n
(  }) N
(  ) S
(char) k
( ** argArray = \() p
(char) k
( **\)malloc\() p
(sizeof) K
(\() p
(char) k
( *\) * \(argCount+1\)\); ) p
(//Null-term) c n
(inated array) N
(                                                            ) p
(//of pointers to arg) c n
(arg_parse.c) (Page 1/3) (Apr 21, 14 19:08) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(ument letters) c n
(  ) p
(if) K
( \(argArray == ) p
(NULL) K
(\){) p n
(    perror\(") S
(Malloc) str
("\);) p n
(    ) S
(return) K
( -1;) p n
(  }) N
(  ptr = line; ) S
(//Reset the pointer) c n
(  ) p
(char) k
( *dst = line;) p n
(  state = 0;) N
() N
() N
(  ) S
(while) K
( \(\(c = *ptr\) != 0\){ ) p
(//Add zero-characters and pointers, removing quotes) c n
() p n
(    ) S
(if) K
( \(state == 0\){  ) p
(//Outside of an argument) c n
(      ) p
(if) K
( \(c == ') p
(") str
('\){) p n
(        state = 1;) N
(      }) N
(      ) S
(else) K
( ) p
(if) K
( \(c != ') p
( ) str
('\){) p n
(        state = 2;) N
(        *dst = c;) N
(        argArray[idx] = dst;) N
(        dst++;) N
(        idx++;) N
(      }) N
(    }) N
(    ) S
(else) K
( ) p
(if) K
(\(state == 1\){ ) p
(//Argument starting with a quote) c n
(      ) p
(if) K
( \(c == ') p
(") str
('\){) p n
(        state = 4;) N
(      }) N
(      ) S
(else) K
({) p n
(        state = 3;) N
(        argArray[idx] = dst;) N
(        *dst = c;) N
(        dst++;) N
(        idx++;) N
(      }) N
(    }) N
(    ) S
(else) K
( ) p
(if) K
(\(state == 2\){ ) p
(//in an argument, not in a quote) c n
(      ) p
(if) K
(\(c == ') p
( ) str
('\){ ) p
(//End of argument) c n
(          state = 0;) p n
(          *dst = ') S
(\\0) str
(';) p n
(          dst++;) N
(      }) N
(      ) S
(else) K
( ) p
(if) K
(\(c == ') p
(") str
('\){) p
(//Entering a quote) c n
(        state = 3;) p n
(      }) N
(      ) S
(else) K
({) p n
(        *dst = c;) N
(        dst++;) N
(      }) N
(    }) N
(    ) S
(else) K
( ) p
(if) K
(\(state == 3\){) p
(//in a quote in an argument) c n
(      ) p
(if) K
(\(c == ') p
(") str
('\){) p n
(        state = 2;) N
(      }) N
(      ) S
(else) K
({) p n
(        *dst = c;) N
(        dst++;) N
(      }) N
(    }) N
(    ) S
(else) K
( ) p
(if) K
(\(state == 4\){) p
(//Two quotes in a row while not in an argument) c n
(      ) p
(if) K
(\(c ==') p
(") str
('\){) p n
(        state = 1; ) S
(//Argument still hasn't started, back in a quote) c n
(      }) p n
(      ) S
(else) K
( ) p
(if) K
(\(c==') p
( ) str
('\) ) p
(//Null argument) c n
(      {) p n
(        state = 0;) N
(        *dst = ') S
(\\0) str
(';) p n
(        argArray[idx] = dst;) N
(        dst++;) N
(arg_parse.c) (Page 2/3) (Apr 21, 14 19:08) title
border
grestore
(Printed by Zachary Quinn Evans) rhead
(arg_parse.c) (1/14) (Friday May 09, 2014) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (3) 2
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(        idx++;) p n
(      }) N
(      ) S
(else) K
({ ) p
(//argument after even number of quotes) c n
(        state = 2;) p n
(        *dst = c;) N
(        argArray[idx] = dst;) N
(        dst++;) N
(        idx++;) N
(      }) N
(    }) N
(    ptr++;) N
(  }) N
(  *dst = 0;) N
(  argArray[argCount] = ) S
(NULL) K
(;) p n
(  *argvp = argArray;) N
(  ) S
(return) K
( argCount;) p n
(}) N
(arg_parse.c) (Page 3/3) (Apr 21, 14 19:08) title
border
grestore
(Printed by Zachary Quinn Evans) rhead
(arg_parse.c) (2/14) (Friday May 09, 2014) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1-2) 3
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* CS 352 -- Builtin commands) c n
( *  $Id: builtin.c,v 1.16 2014/05/07 19:19:38 evansz2 Exp $) N
( *  Zach Evans) N
( *  CSCI 352) N
( *  Spring 2014) N
( */) N
(#include) K
( <stdio.h>) p n
(#include) K
( <string.h>) p n
(#include) K
( <unistd.h>) p n
(#include) K
( <errno.h>) p n
(#include) K
( <stdlib.h>) p n
(#include) K
( <sys/types.h>) p n
(#include) K
( <sys/wait.h>) p n
(#include) K
( <sys/stat.h>) p n
(#include) K
( <ctype.h>) p n
(#include) K
( <time.h>) p n
(#include) K
( <pwd.h>) p n
(#include) K
( <grp.h>) p n
(#include) K
( ") p
(proto.h) str
(") p n
() N
(#define) K
( NUM_COMMANDS 8) p n
() N
() N
(static) K
( ) p
(int) k
( isNum\() p
(char) k
( *numStart\){) p n
(  ) S
(int) k
( isDigit = 1;) p n
(  ) S
(char) k
( c;) p n
(  ) S
(while) K
( \(\(c = *numStart++\) != ') p
(\\0) str
('\){) p n
(    ) S
(if) K
( \(!isdigit\(c\)\){) p n
(      isDigit = 0;) N
(    }) N
(  }) N
(  ) S
(return) K
( isDigit;) p n
(}) N
() N
(int) k
( aecho\() p
(int) k
( argc, ) p
(char) k
( ** argv\){) p n
(    ) S
(int) k
( nMode = 0;) p n
(    ) S
(int) k
( first = 1;) p n
(    ) S
(if) K
( \(argc == 0\){) p n
(      dprintf\(1,") S
(\\n) str
("\);) p n
(      ) S
(return) K
( 0;) p n
(    }) N
(    ) S
(if) K
( \(argc > 1 && strncmp\(") p
(-n) str
(", argv[1], 2\) == 0\){) p n
(      nMode = 1;) N
(    }) N
(    ) S
(int) k
( idx = nMode?2:1;) p n
() N
(    ) S
(for) K
( \(; idx < argc; idx++\){) p n
(      ) S
(if) K
( \(first\){) p n
() N
(        dprintf\(1,") S
(%s) str
(", argv[idx]\);) p n
(        first = 0;) N
(      }) N
(      ) S
(else) K
({) p n
(        dprintf\(1, ") S
( %s) str
(", argv[idx]\);) p n
(      }) N
() N
(    }) N
(    ) S
(if) K
( \(!nMode\){) p n
(      dprintf\(1, ") S
(\\n) str
("\);) p n
(    }) N
(    ) S
(return) K
( 0;) p n
(}) N
() N
(int) k
( exitCommand\() p
(int) k
( argc, ) p
(char) k
( ** argv\){) p n
(  ) S
(if) K
( \(argc == 1\){) p n
(    exit\(0\);) N
(  }) N
(  ) S
(else) K
( ) p
(if) K
( \(argc == 2\){) p n
(    exit\(atoi\(argv[1]\)\);) N
(builtin.c) (Page 1/5) (May 08, 14 22:34) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(  }) p n
(  ) S
(else) K
({) p n
(    dprintf\(1, ") S
(Usage: exit [status]\\n) str
("\);) p n
(    ) S
(return) K
( 1;) p n
(  }) N
(  ) S
(return) K
( 0;) p n
(}) N
() N
(int) k
( envset\() p
(int) k
( argc, ) p
(char) k
( ** argv\){) p n
(  ) S
(if) K
( \(argc == 3\){) p n
(    setenv\(argv[1], argv[2], 1\);) N
(  }) N
(  ) S
(else) K
({) p n
(    dprintf\(1, ") S
(Usage: envset NAME value) str
("\);) p n
(    ) S
(return) K
( 1;) p n
(  }) N
(  ) S
(return) K
( 0;) p n
(}) N
() N
(int) k
( envunset\() p
(int) k
( argc, ) p
(char) k
( ** argv\){) p n
(  ) S
(if) K
( \(argc == 2\){) p n
(    unsetenv\(argv[1]\);) N
(  }) N
(  ) S
(else) K
({) p n
(    dprintf\(1, ") S
(Usage: envunset NAME) str
("\);) p n
(    ) S
(return) K
( 1;) p n
(  }) N
(  ) S
(return) K
( 0;) p n
(}) N
() N
(int) k
( cd\() p
(int) k
( argc, ) p
(char) k
( ** argv\){) p n
(  ) S
(/*) c n
(  Changes the working directory to dir. Changes working directory to environment) N
(  variable HOME if set. Error otherwise.) N
(  Usage: cd [dir]) N
(  */) N
() p n
(  ) S
(if) K
( \(argc == 1\){) p n
(    ) S
(char) k
( *home;) p n
(    ) S
(if) K
( \(\(home = getenv\(") p
(HOME) str
("\)\)\){) p n
(      chdir\(home\);) N
(    }) N
(    ) S
(else) K
({) p n
(      dprintf\(2, ") S
(No home directory specified.\\n) str
("\);) p n
(      ) S
(return) K
( 1;) p n
(    }) N
(  }) N
(  ) S
(else) K
({) p n
(    ) S
(if) K
( \(chdir\(argv[1]\)<0\){) p n
(      dprintf\(2, ") S
(%s\\n) str
(",strerror\(errno\)\);) p n
(      ) S
(return) K
( 1;) p n
(    }) N
() N
(  }) N
(  ) S
(return) K
( 0;) p n
(}) N
() N
(int) k
( shift\() p
(int) k
( argc, ) p
(char) k
( **argv\){) p n
(  ) S
(/*) c n
(  Shifts $n arguments by index n. Shifts by 1 if called without arguments.) N
(  Usage: shift [n]) N
(  */) N
(  ) p
(int) k
( inShift;) p n
() N
(  ) S
(if) K
(\(argc == 1\){) p n
(    inShift = 1;) N
(  }) N
(  ) S
(else) K
( ) p
(if) K
( \(argc == 2 && isNum\(argv[1]\)\){) p n
(    inShift = atoi\(argv[1]\);) N
(builtin.c) (Page 2/5) (May 08, 14 22:34) title
border
grestore
(Printed by Zachary Quinn Evans) rhead
(builtin.c) (3/14) (Friday May 09, 2014) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (3-4) 4
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(  }) p n
(  ) S
(else) K
({) p n
(    dprintf\(2, ") S
(Usage: shift [n]\\n) str
("\);) p n
(    ) S
(return) K
( 1;) p n
(  }) N
(  ) S
(if) K
(\(inShift >= \(mainargc-1-shiftIndex\)\){) p n
(    dprintf\(2,") S
(Shift index too high\\n) str
("\);) p n
(    ) S
(return) K
( 1;) p n
(  }) N
(  ) N
(  shiftIndex += inShift;) N
(  ) S
(return) K
( 0;) p n
(}) N
() N
(int) k
( unshift\() p
(int) k
( argc, ) p
(char) k
( **argv\){) p n
(  ) S
(/*) c n
(  Shifts $n arguments back by index n. Resets shift index if called without argu) N
(ments.) N
(  Usage: unshift [n]) N
(  */) N
(  ) p
(if) K
(\(argc == 1\){) p n
(    shiftIndex = 0;) N
(    ) S
(return) K
( 0;) p n
(  }) N
(  ) S
(else) K
( ) p
(if) K
(\(argc == 2 && isNum\(argv[1]\)\){) p n
(    ) S
(int) k
( inShift = atoi\(argv[1]\);) p n
(    ) S
(if) K
( \(inShift > shiftIndex\){) p n
(      dprintf\(2, ") S
(Shift index too high\\n) str
("\);) p n
(      ) S
(return) K
( 1;) p n
(    }) N
(    ) S
(else) K
({) p n
(      shiftIndex -= inShift;) N
(    }) N
(  }) N
(  ) S
(return) K
( 0;) p n
(}) N
() N
(int) k
( sstat\() p
(int) k
( argc, ) p
(char) k
( **argv\){) p n
(  ) S
(/*) c n
(  Shows statistics for files given in arguments) N
(  file-name user-name group-name permission-list num-links filesize modification) N
(-time) N
(  Usage: sstat file [file...]) N
(  */) N
(  ) p
(struct) k
( stat fileStat;) p n
(  ) S
(struct) k
( passwd *userStruct;) p n
(  ) S
(struct) k
( group *groupStruct;) p n
(  ) S
(char) k
( *userPrint;) p n
(  ) S
(char) k
( *groupPrint;) p n
(  ) S
(char) k
( *filePrint;) p n
() N
(  ) S
(if) K
( \(argc <= 1\){) p n
(    dprintf\(2, ") S
(Usage: sstat file [file...]\\n) str
("\);) p n
(    ) S
(return) K
( 1;) p n
(  }) N
(  ) S
(else) K
({) p n
(    ) S
(int) k
( i;) p n
(    ) S
(for) K
( \(i = 1; i <= argc-1; i++\){) p n
(      ) S
(if) K
( \(stat\(argv[i], &fileStat\) < 0\){) p n
(        dprintf\(2, ") S
(Invalid file name: %s\\n) str
(", argv[i]\); ) p
(/*Bad file name given*/) c n
() p 8 T () S 16 T () S
(return) K
( 1;  ) p n
(      }) N
(      ) S
(else) K
({) p n
(        userStruct = getpwuid\(fileStat.st_uid\);) N
(        groupStruct = getgrgid\(fileStat.st_gid\);) N
(        ) S
(if) K
( \(userStruct != ) p
(NULL) K
(\){ ) p
(/* Set User name or uid */) c n
(          userPrint = userStruct->pw_name;) p n
(        }) N
(        ) S
(else) K
({) p n
(builtin.c) (Page 3/5) (May 08, 14 22:34) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(          snprintf\(userPrint, 12, ") p
(%i) str
(", fileStat.st_uid\);) p n
(        }) N
() N
(        ) S
(if) K
( \(groupStruct != ) p
(NULL) K
(\){ ) p
(/*Set Group name or gid */) c n
(          groupPrint = groupStruct->gr_name;) p n
(        }) N
(        ) S
(else) K
({) p n
(          snprintf\(groupPrint, 12, ") S
(%i) str
(", fileStat.st_gid\);) p n
(        }) N
() N
() S 8 T () S 16 T () S
(if) K
( \(S_ISBLK\(fileStat.st_mode\)\){ ) p
(/* File type flag */) c n
() p 8 T () S 16 T () S 24 T (filePrint = ") S
(b) str
(";) p n
() S 8 T () S 16 T (}) N
() S 8 T () S 16 T () S
(else) K
( ) p
(if) K
( \(S_ISCHR\(fileStat.st_mode\)\){) p n
() S 8 T () S 16 T () S 24 T (filePrint = ") S
(c) str
(";) p n
() S 8 T () S 16 T (}) N
() S 8 T () S 16 T () S
(else) K
( ) p
(if) K
( \(S_ISDIR\(fileStat.st_mode\)\){) p n
() S 8 T () S 16 T () S 24 T (filePrint = ") S
(d) str
(";) p n
() S 8 T () S 16 T (}) N
() S 8 T () S 16 T () S
(else) K
( ) p
(if) K
(\(S_ISLNK\(fileStat.st_mode\)\){) p n
() S 8 T () S 16 T () S 24 T (filePrint = ") S
(l) str
(";) p n
() S 8 T () S 16 T (}) N
() S 8 T () S 16 T () S
(else) K
( ) p
(if) K
(\(S_ISSOCK\(fileStat.st_mode\)\){) p n
() S 8 T () S 16 T () S 24 T (filePrint = ") S
(s) str
(";) p n
() S 8 T () S 16 T (}) N
() S 8 T () S 16 T () S
(else) K
( ) p
(if) K
(\(S_ISFIFO\(fileStat.st_mode\)\){) p n
() S 8 T () S 16 T () S 24 T (filePrint = ") S
(p) str
(";) p n
() S 8 T () S 16 T (}) N
() S 8 T () S 16 T () S
(else) K
( ) p
(if) K
(\(S_ISREG\(fileStat.st_mode\)\){) p n
() S 8 T () S 16 T () S 24 T (filePrint = ") S
(-) str
(";) p n
() S 8 T () S 16 T (}) N
() S 8 T () S 16 T () S
(else) K
({) p n
() S 8 T () S 16 T () S 24 T (filePrint = ") S
(?) str
(";) p n
() S 8 T () S 16 T (}) N
() N
(        dprintf\(1, ") S
(%s %s %s %s%s%s%s%s%s%s%s%s%s %lu %llu %s) str
(",argv[i],\\) p n
() S 8 T () S 16 T () S 24 T ( userPrint,groupPrint,filePrint,\\) N
() S 8 T () S 16 T () S 24 T () S 32 T ( \(\(fileStat.st_mode & S_IRUSR\)?") S
(r) str
(":") p
(-) str
("\),\\) p n
() S 8 T () S 16 T () S 24 T () S 32 T () S 40 T ( \(\(fileStat.st_mode & S_IWUSR\)?") S
(w) str
(":") p
(-) str
("\)) p n
(,\\) N
() S 8 T () S 16 T () S 24 T () S 32 T () S 40 T () S 48 T ( \(\(fileStat.st_mode & S_IXUSR\)?") S
() str n
(x) S
(":") p
(-) str
("\),\\) p n
() S 8 T () S 16 T () S 24 T () S 32 T () S 40 T () S 48 T () S 56 T ( \(\(fileStat.st_mode & S_) N
(IRGRP\)?") S
(r) str
(":") p
(-) str
("\),\\) p n
() S 8 T () S 16 T () S 24 T () S 32 T () S 40 T () S 48 T () S 56 T () S 64 T ( \(\(fileStat.st_m) N
(ode & S_IWGRP\)?") S
(w) str
(":") p
(-) str
("\),\\) p n
() S 8 T () S 16 T () S 24 T () S 32 T () S 40 T () S 48 T () S 56 T () S 64 T () S 72 T ( \(\(fileS) N
(tat.st_mode & S_IXGRP\)?") S
(x) str
(":") p
(-) str
("\),\\) p n
() S 8 T () S 16 T () S 24 T () S 32 T () S 40 T () S 48 T () S 56 T () S 64 T () S 72 T () S 80 T () N
( \(\(fileStat.st_mode & S_IROTH\)?") S
(r) str
(":") p
(-) str
("\),\\) p n
() S 8 T () S 16 T () S 24 T () S 32 T () S 40 T () S 48 T () S 56 T () S 64 T () S 72 T () S 80 T () N
() S 0 T ( \(\(fileStat.st_mode & S_IWOTH\)?") S
(w) str
(":") p
(-) str
("\),\\) p n
() S 8 T () S 16 T () S 24 T () S 32 T () S 40 T () S 48 T () S 56 T () S 64 T () S 72 T () S 80 T () N
() S 0 T () S 8 T ( \(\(fileStat.st_mode & S_IXOTH\)?") S
(x) str
(":") p
(-) str
("\), \\) p n
() S 8 T () S 16 T () S 24 T () S 32 T () S 40 T () S 48 T () S 56 T () S 64 T () S 72 T () S 80 T () N
() S 0 T () S 8 T () S 16 T ( \() S
(unsigned) k
( ) p
(long) k
(\)fileStat.st_nlink,\\) p n
() S 8 T () S 16 T () S 24 T () S 32 T () S 40 T () S 48 T () S 56 T () S 64 T () S 72 T () S 80 T () N
() S 0 T () S 8 T () S 16 T () S 24 T ( \() S
(unsigned) k
( ) p
(long) k
( ) p
(long) k
(\)fileStat.st_size,\\) p n
() S 8 T () S 16 T () S 24 T () S 32 T () S 40 T () S 48 T () S 56 T () S 64 T () S 72 T () S 80 T () N
() S 0 T () S 8 T () S 16 T () S 24 T () S 32 T ( asctime\(localtime\(&fileStat.st_mtime\)\)\);) N
(      }) N
(    }) N
(  }) N
(  ) S
(return) K
( 0;) p n
() N
(}) N
() N
(static) K
( ) p
(const) K
( ) p
(char) k
( *commandNames[NUM_COMMANDS] = {") p
(aecho) str
(", ") p
(exit) str
(", ") p
(envset) str
(", ") p
(envunset) str
(") p n
(, ") S
(cd) str
(", ") p
(shift) str
(", ") p
(unshift) str
(", ") p
(sstat) str
("};) p n
(builtin.c) (Page 4/5) (May 08, 14 22:34) title
border
grestore
(Printed by Zachary Quinn Evans) rhead
(builtin.c) (4/14) (Friday May 09, 2014) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (5) 5
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(static) K
( ) p
(int) k
( \(*commandList[NUM_COMMANDS]\)\() p
(int) k
(, ) p
(char) k
( **\) = {&aecho, &exitCommand, &) p n
(envset, &envunset, &cd, &shift, &unshift, &sstat};) N
() N
(int) k
( runBuiltin\() p
(int) k
( argc, ) p
(char) k
( **argv\){) p n
(  ) S
(int) k
( ran = 0;) p n
(  ) S
(int) k
( i;) p n
(  ) S
(char) k
( *name = argv[0];) p n
(  ) S
(for) K
(\(i = 0; i<NUM_COMMANDS;i++\){) p n
(    ) S
(if) K
( \(strcmp\(name, commandNames[i]\) == 0\){) p n
(      ) S
(int) k
( exitStatus = commandList[i]\(argc, argv\);) p n
(      lastExit = exitStatus;) N
(      ran = 1;) N
(    }) N
(  }) N
(  ) S
(return) K
( ran;) p n
(}) N
(builtin.c) (Page 5/5) (May 08, 14 22:34) title
border
grestore
(Printed by Zachary Quinn Evans) rhead
(builtin.c) (5/14) (Friday May 09, 2014) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1-2) 6
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
( ) p
(/* CS 352 -- Expand Function) c n
( * $Id: expand.c,v 1.15 2014/05/07 19:13:29 evansz2 Exp $) N
( *  Zach Evans) N
( *  CSCI 352) N
( *  Spring 2014) N
( */) N
() p n
(#include) K
( ") p
(proto.h) str
(") p n
(#include) K
( <stdio.h>) p n
(#include) K
( <string.h>) p n
(#include) K
( <unistd.h>) p n
(#include) K
( <errno.h>) p n
(#include) K
( <stdlib.h>) p n
(#include) K
( <sys/types.h>) p n
(#include) K
( <sys/wait.h>) p n
(#include) K
( <ctype.h>) p n
(#include) K
( <strings.h>) p n
(#include) K
( <math.h>) p n
(#include) K
( <limits.h>) p n
(#include) K
( <dirent.h>) p n
() N
(int) k
( contextMatch\() p
(char) k
( *contextString, ) p
(char) k
( *matchString\){) p n
() S 8 T () N
() S 8 T () S
(int) k
( contextLength = strlen\(contextString\);) p n
() S 8 T () S
(int) k
( matchLength = strlen\(matchString\);) p n
() S 8 T () N
() S 8 T () S
(int) k
( i;) p n
() S 8 T () S
(if) K
( \(matchLength < contextLength || contextLength == 0\){) p n
() S 8 T () S 16 T () S
(return) K
( 0;) p n
() S 8 T (}) N
() S 8 T () S
(for) K
( \(i = 0; i < contextLength; i++\){) p n
() S 8 T () S 16 T () N
() S 8 T () S 16 T () S
(if) K
( \(contextString[i] != matchString[matchLength-contextLength+i]) p n
(\){) N
() S 8 T () S 16 T () S 24 T () S
(return) K
( 0;) p n
() S 8 T () S 16 T (}) N
() S 8 T (}) N
() S 8 T () S
(return) K
( 1;) p n
(}) N
() N
(int) k
( replWithContextFiles\() p
(char) k
( *contextStart,) p
(char) k
( *replBuf, ) p
(int) k
( *currentSize, ) p
(int) k
() p n
( maxSize, ) S
(int) k
( *contextLength\){) p n
() S 8 T () S
(/*) c n
() S 8 T (contextStart: beginning of the context) N
() S 8 T (replBuf: The new buffer in which the replaced filenames are placed) N
() S 8 T (currentSize: Pointer to the variable holding the current size of the buf) N
(fer) N
() S 8 T (maxSize: maximum size of the buffer) N
() S 8 T (contextLength: returns the length of the context for the walking pointer) N
( to use) N
() S 8 T (*/) N
() p 8 T () S
(char) k
( contextBuffer[LINELEN];) p n
() S 8 T () S
(int) k
( ctxBufIdx = 0; ) p
(//Context buffer index) c n
() p 8 T (DIR *workingDir = opendir\(") S
(.) str
("\);) p n
() S 8 T () S
(struct) k
( dirent *currentDir;) p n
() S 8 T () S
(int) k
( nameLen;) p n
() S 8 T () S
(int) k
( first = 1;) p n
() S 8 T () S
(int) k
( replCount = 0;) p n
() S 8 T () S
(char) k
( *walk;) p n
() S 8 T () S
(int) k
( ctxLen;) p n
() S 8 T () S
(for) K
( \(walk = contextStart +1;*walk != ') p
( ) str
(' && *walk !=') p
(") str
(' && *walk !=0;wal) p n
(k++\){) N
() S 8 T () S 16 T (strncpy\(&contextBuffer[ctxBufIdx], walk, 1\);) N
() S 8 T () S 16 T (ctxBufIdx++;) N
() S 8 T (}) N
() S 8 T (contextBuffer[ctxBufIdx] = ') S
(\\0) str
(';) p n
() S 8 T (ctxLen = strlen\(contextBuffer\);) N
() S 8 T (*contextLength = ctxLen;) N
() S 8 T () N
(expand.c) (Page 1/6) (May 08, 14 22:34) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p 8 T () S
(while) K
(\(\(currentDir = readdir\(workingDir\)\) != ) p
(NULL) K
(\){) p n
() S 8 T () S 16 T () S
(if) K
( \(currentDir->d_name[0] != ') p
(.) str
(' && contextMatch\(contextBuffer, ) p n
(currentDir->d_name\)\){) N
() S 8 T () S 16 T () S 24 T (nameLen = strlen\(currentDir->d_name\);) N
() S 8 T () S 16 T () S 24 T () S
(if) K
( \(nameLen <= maxSize-\(*currentSize\)\){) p 64 T () N
() S 8 T () S 16 T () S 24 T () S 32 T () S
(if) K
( \(first == 1\){) p n
() S 8 T () S 16 T () S 24 T () S 32 T () S 40 T (first = 0;) N
() S 8 T () S 16 T () S 24 T () S 32 T (}) N
() S 8 T () S 16 T () S 24 T () S 32 T () S
(else) K
({) p n
() S 8 T () S 16 T () S 24 T () S 32 T () S 40 T (strncpy\(&replBuf[*currentSize], ") S
( ) str
(", 1\);) p n
() S 8 T () S 16 T () S 24 T () S 32 T () S 40 T (*currentSize += 1;) N
() S 8 T () S 16 T () S 24 T () S 32 T (}) N
() S 8 T () S 16 T () S 24 T () S 32 T (strncpy\(&replBuf[*currentSize], currentDir->d_na) N
(me, nameLen\);) N
() S 8 T () S 16 T () S 24 T () S 32 T (*currentSize += nameLen;) N
() S 8 T () S 16 T () S 24 T () S 32 T (replCount ++;) N
() S 8 T () S 16 T () S 24 T () S 32 T () N
() S 8 T () S 16 T () S 24 T (}) N
() S 8 T () S 16 T () S 24 T () S
(else) K
({) p n
() S 8 T () S 16 T () S 24 T () S 32 T () S
(return) K
( -1;) p n
() S 8 T () S 16 T () S 24 T (}) S 32 T () N
() S 8 T () S 16 T () S 24 T () N
() S 8 T () S 16 T (}) N
() S 8 T (}) N
() S 8 T () S
(if) K
( \(replCount == 0\){ ) p
(//Keep the pattern in the buffer) c n
() p 8 T () S 16 T (ctxLen++;) N
() S 8 T () S 16 T (strncpy\(&replBuf[*currentSize], contextStart, ctxLen\);) N
() S 8 T () S 16 T (*currentSize += ctxLen;) N
() S 8 T (}) N
() S 8 T () N
() S 8 T () S
(return) K
( 0;) p n
(}) N
() N
(int) k
( replWithAllFiles\() p
(char) k
( *replBuf, ) p
(int) k
( *currentSize, ) p
(int) k
( maxSize\){) p n
() S 8 T () S
(/*) c n
() S 8 T (replBuf: buffer to place in the new files) N
() S 8 T (currentSize: pointer to the variable holding the current size of the new) N
( buffer) N
() S 8 T (maxSize: max size of the new buffer) N
() S 8 T (*/) N
() p 8 T (DIR *workingDir = opendir\(") S
(.) str
("\);) p n
() S 8 T () S
(struct) k
( dirent *currentDir;) p n
() S 8 T () S
(int) k
( nameLen;) p n
() S 8 T () S
(int) k
( first = 1;) p n
() S 8 T () S
(while) K
(\(\(currentDir = readdir\(workingDir\)\) != ) p
(NULL) K
(\){) p n
() S 8 T () S 16 T () S
(if) K
(\(currentDir->d_name[0] != ') p
(.) str
('\){) p n
() S 8 T () S 16 T () S 24 T (nameLen = strlen\(currentDir->d_name\);) N
() S 8 T () S 16 T () S 24 T () S
(if) K
( \(nameLen <= maxSize-\(*currentSize\)\){) p 64 T () N
() S 8 T () S 16 T () S 24 T () S 32 T () S
(if) K
( \(first == 1\){) p n
() S 8 T () S 16 T () S 24 T () S 32 T () S 40 T (first = 0;) N
() S 8 T () S 16 T () S 24 T () S 32 T (}) N
() S 8 T () S 16 T () S 24 T () S 32 T () S
(else) K
({) p n
() S 8 T () S 16 T () S 24 T () S 32 T () S 40 T (strncpy\(&replBuf[*currentSize], ") S
( ) str
(", 1\);) p n
() S 8 T () S 16 T () S 24 T () S 32 T () S 40 T (*currentSize += 1;) N
() S 8 T () S 16 T () S 24 T () S 32 T (}) N
() S 8 T () S 16 T () S 24 T () S 32 T (strncpy\(&replBuf[*currentSize], currentDir->d_na) N
(me, nameLen\);) N
() S 8 T () S 16 T () S 24 T () S 32 T (*currentSize += nameLen;) N
() S 8 T () S 16 T () S 24 T () S 32 T () N
() S 8 T () S 16 T () S 24 T (}) N
() S 8 T () S 16 T () S 24 T () S
(else) K
({) p n
() S 8 T () S 16 T () S 24 T () S 32 T () S
(return) K
( -1;) p n
() S 8 T () S 16 T () S 24 T (}) S 32 T () N
() S 8 T () S 16 T (}) S 24 T () N
() S 8 T (}) N
() S 8 T () S
(return) K
( 0;) p n
(}) N
() N
() N
(expand.c) (Page 2/6) (May 08, 14 22:34) title
border
grestore
(Printed by Zachary Quinn Evans) rhead
(expand.c) (6/14) (Friday May 09, 2014) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (3-4) 7
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(int) k
( replWalkInt\() p
(char) k
( *replBuf, ) p
(int) k
( replInt, ) p
(int) k
( *newLen, ) p
(int) k
( maxSize\){) p n
(  ) S
(/*) c n
(  replBuf: Buffer to place replacement) N
(  replInt: The int to replace with its ascii value) N
(  newLen: pointer to the size index of the new buffer) N
(  maxSize: max size of the new buffer) N
(  */) N
(  ) p
(int) k
( intSize = floor\(log10\(INT_MAX\)+1\);) p n
(  ) S
(char) k
( digitBuf[intSize];) p n
(  ) S
(int) k
( intLen = snprintf\(digitBuf, intSize+1, ") p
(%i) str
(", replInt\);) p n
(  ) S
(if) K
( \(intLen < maxSize-\(*newLen\)\){) p n
(    strncpy\(&replBuf[*newLen], digitBuf, intSize\);) N
(    *newLen += intLen;) N
(    replBuf[*newLen] = ') S
( ) str
(';) p n
(    ) S
(return) K
( 0;) p n
(  }) N
(  ) S
(else) K
({) p n
(    ) S
(return) K
( -1;) p n
(  }) N
(}) N
(int) k
( replWalkPid\() p
(char) k
( *replBuf, pid_t replpid, ) p
(int) k
( *newLen, ) p
(int) k
( maxSize\){) p n
(  ) S
(/*) c n
(  replBuf: Buffer to place replacement) N
(  replInt: The int to replace with its ascii value) N
(  newLen: pointer to the size index of the new buffer) N
(  maxSize: max size of the new buffer) N
(  */) N
() p 8 T () N
(  ) S
(int) k
( intSize = 10;) p n
(  ) S
(char) k
( digitBuf[intSize];) p n
(  ) S
(int) k
( intLen = snprintf\(digitBuf, intSize+1, ") p
(%i) str
(", replpid\);) p n
(  ) S
(if) K
( \(intLen < maxSize-\(*newLen\)\){) p n
(    strncpy\(&replBuf[*newLen], digitBuf, intSize\);) N
(    *newLen += intLen;) N
(    replBuf[*newLen] = ') S
( ) str
(';) p n
(    ) S
(return) K
( 0;) p n
(  }) N
(  ) S
(else) K
({) p n
(    ) S
(return) K
( -1;) p n
(  }) N
(}) N
() N
(int) k
( parseInt\() p
(char) k
( *start, ) p
(char) k
( **finish\){) p n
(  ) S
(char) k
( digitBuf[LINELEN];) p n
(  ) S
(int) k
( i = 0;) p n
(  ) S
(char) k
( c;) p n
(  bzero\(digitBuf, LINELEN\);) N
(  ) S
(while) K
(\(isdigit\(c = *start++\)\){) p n
(    digitBuf[i++] = c;) N
(  }) N
(  *finish = --start;) N
(  ) S
(return) K
( atoi\(digitBuf\);) p n
(}) N
() N
(char) k
( *findEndChar\() p
(char) k
( *start, ) p
(char) k
( endChar, ) p
(int) k
( *len\){) p n
(  ) S
(/*) c n
(  start: pointer to the character to start the search from) N
(  endChar: The character you're looking for) N
(  len: Pointer to an integer to fill with the length of the argument) N
() N
(  Returns pointer to the character you're attempting to find or NULL if never fo) N
(und) N
(  */) N
(  ) p
(char) k
( c;) p n
(  ) S
(int) k
( dist = 0;) p n
(  ) S
(char) k
( *walk = start;) p n
(  ) S
(while) K
( \(\(c = *walk\)!=0\){) p n
(    ) S
(if) K
(\(c == endChar\){) p n
(      *len = dist;) N
(expand.c) (Page 3/6) (May 08, 14 22:34) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(      ) p
(return) K
( walk;) p n
(    }) N
(    dist++;) N
(    walk++;) N
(  }) N
(  ) S
(return) K
( ) p
(NULL) K
(;) p n
(}) N
() N
(char) k
( *findReplaceEnv\() p
(char) k
( *replStart, ) p
(int) k
( argLen\){) p n
(  ) S
(/*) c n
(  replStart: points to $ in "${HOME}") N
(  argLen: ${HOME} would have argLen of 4) N
() N
(  Returns string pointing to the proper environment variable string.) N
(  */) N
() p n
(  ) S
(char) k
( getEnvBuf[1024]; ) p
(//Buffer for input to getenv\(\)) c n
(  strncpy\(getEnvBuf, replStart+2, argLen\); ) p
(//Copy over just the name of the argu) c n
(ment) N
(  getEnvBuf[argLen] = 0; ) p
(//add null terminator) c n
(  ) p
(char) k
( *envString;) p n
(  ) S
(if) K
( \(\(envString = getenv\(getEnvBuf\)\)!=) p
(NULL) K
(\){) p n
(    ) S
(return) K
( envString;) p n
(  }) N
(  ) S
(else) K
({) p n
(    ) S
(return) K
( "";) p n
(  }) N
() N
(}) N
() N
(char) k
( findNextChar\() p
(char) k
( *start\){) p n
(  ) S
(/*) c n
(  start: Pointer to the starting character) N
() N
(  Returns character after start) N
(  */) N
(  ) p
(return) K
(\(*\(start+1\)\);) p n
(}) N
() N
(int) k
( expand \() p
(char) k
( *orig, ) p
(char) k
( *new, ) p
(int) k
( newsize\){) p n
(  ) S
(/*) c n
(  orig: Original buffer \(variables to be replaced\)) N
(  new: New buffer \(variables have been replaced\)) N
(  newsize: Size of the new buffer to avoid overflow) N
(  */) N
(  ) p
(int) k
( origLen = strlen\(orig\); ) p
(//Length of the original buffer) c n
(  ) p
(int) k
( newLen = 0; ) p
(//Length of the new buffer\(updated with writes\)) c n
(  ) p
(char) k
( *replEnd; ) p
(//Pointer to the end of a replacement) c n
(  ) p
(int) k
( replLen; ) p
(//Length of the text to be replaced) c n
(  ) p
(char) k
( c; ) p
(//Character for parsing string) c n
(  ) p
(char) k
( *walk = orig; ) p
(//Walking pointer for original buffer) c n
() p n
(  ) S
(while) K
( \(\(c = *walk\)!=0 && walk-orig < origLen && newLen < newsize\){) p n
(    ) S
(if) K
( \(c == ') p
($) str
('\){) p n
(      ) S
(char) k
( next = findNextChar\(walk\); ) p
(//Next character in the buffer) c n
() p n
(      ) S
(if) K
(\(next == ') p
($) str
('\){ ) p
(//Found $$) c n
(        replWalkPid\(new, getpid\(\), &newLen, LINELEN\);) p n
() S 8 T () S 16 T (walk += 2;) N
(    ) N
(      }) N
(      ) S
(else) K
( ) p
(if) K
(\(next ==') p
({) str
('\){ ) p
(//found ${) c n
(        replEnd = findEndChar\(walk+2, ') p
(}) str
(', &replLen\); ) p
(//Start the search on H of) c n
( "${HOME}", will fill replLen with 0 if given "${}") N
(        ) p
(if) K
( \(replEnd == ) p
(NULL) K
(\){) p n
(          dprintf\(2, ") S
(Missing end brace for environment variable\\n) str
("\);) p n
(          ) S
(return) K
( -1;) p n
(        }) N
(        ) S
(else) K
({) p n
(expand.c) (Page 4/6) (May 08, 14 22:34) title
border
grestore
(Printed by Zachary Quinn Evans) rhead
(expand.c) (7/14) (Friday May 09, 2014) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (5-6) 8
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(          ) p
(char) k
( *envReplace = findReplaceEnv\(walk, replLen\); ) p
(//String that replac) c n
(es variable) N
(          ) p
(int) k
( envLen = strlen\(envReplace\); ) p
(//Length of the new text) c n
(          ) p
(if) K
( \(newsize-newLen >= envLen\){) p n
(            strncpy\(&new[newLen], envReplace, envLen\); ) S
(//Copy over the new text) c n
(            newLen+= envLen; ) p
(//Increase the length of the new line by the size o) c n
(f the new text) N
(            walk = replEnd+1; ) p
(//Move the walking pointer to the end of the varia) c n
(ble text) N
(          }) p n
(          ) S
(else) K
({) p n
(            dprintf\(2, ") S
(Expanded string too long\\n) str
("\);) p n
(            ) S
(return) K
( -1;) p n
(          }) N
(        }) N
(      }) N
(      ) S
(else) K
( ) p
(if) K
(\(isdigit\(next\)\){ ) p
(//Found argv replacement) c n
(        ) p
(int) k
( argNum = parseInt\(walk+1, &walk\); ) p
(//Moves walk past the int) c n
() p 8 T () S 16 T () S
(if) K
( \(argNum == 0 && interactive\){) p n
() S 8 T () S 16 T () S 24 T (strncpy\(&new[newLen], mainargv[0], strlen\(mainargv[0]\)\);) N
() S 8 T () S 16 T () S 24 T (newLen += strlen\(mainargv[0]\);) N
() S 8 T () S 16 T (}) N
() S 8 T () S 16 T () S
(else) K
({) p n
() S 8 T (        argNum += shiftIndex;) N
() S 8 T (        ) S
(if) K
( \(argNum < mainargc - 1\){) p n
() S 8 T (          ) S
(int) k
( newArgLen = strlen\(mainargv[argNum+1]\);) p n
() S 8 T (          strncpy\(&new[newLen], mainargv[argNum+1], newArgLen\);) N
() S 8 T (          newLen += newArgLen;) N
() S 8 T (        }) N
() S 8 T () S 16 T (}) N
(      }) N
(      ) S
(else) K
( ) p
(if) K
(\(next == ') p
(#) str
('\){ ) p
(//Show number of available arguments) c n
() p 8 T () S 16 T (  ) S
(if) K
( \(interactive\){) p n
() S 8 T () S 16 T () S 24 T (  replWalkInt\(new, 1, &newLen, LINELEN\);) N
() S 8 T () S 16 T (  }) N
() S 8 T () S 16 T (  ) S
(else) K
({) p n
() S 8 T () S 16 T () S 24 T (  replWalkInt\(new, mainargc-1-shiftIndex, &newLen, LINEL) N
(EN\);) N
() S 8 T () S 16 T (  }) N
(        walk += 2;) N
(      }) N
(      ) S
(else) K
( ) p
(if) K
(\(next == ') p
(?) str
('\){ ) p
(//Show last exit value) c n
() p 8 T () S 16 T (replWalkInt\(new, lastExit, &newLen, LINELEN\);) N
(        walk += 2;) N
() N
(      ) N
(      }) N
(      ) S
(else) K
({ ) p
(//Not a special $) c n
(        strncpy\(&new[newLen], walk, 1\); ) p
(//Copy over $) c n
(        newLen++;) p n
(        walk++;) N
(      }) N
(    }) N
() S 8 T () S
(else) K
( ) p
(if) K
( \(c == ') p
(*) str
('\){) p n
() S 8 T () S 16 T () S
(if) K
( \(\(*\(walk+1\) == ') p
( ) str
(' ||*\(walk+1\) == ') p
(\\0) str
('\) && walk-orig >= 1 && \() p n
(*\(walk-1\)== ') S
( ) str
('  || *\(walk-1\) == ') p
(") str
('\)\){) p n
() S 8 T () S 16 T () S 24 T () S
(if) K
(\(replWithAllFiles\(new, &newLen, newsize\) < 0\){) p n
() S 8 T () S 16 T () S 24 T () S 32 T (dprintf\(2, ") S
(Expanded string too long\\n) str
("\);) p n
() S 8 T () S 16 T () S 24 T () S 32 T () S
(return) K
( -1;) p n
() S 8 T () S 16 T () S 24 T (}) N
() S 8 T () S 16 T (}) N
() S 8 T () S 16 T () S
(else) K
( ) p
(if) K
(\(*\(walk+1\) != ') p
( ) str
(' && *\(walk+1\) != ') p
(\\0) str
(' && walk-orig >= 1\){) p n
() S 8 T () S 16 T () S 24 T () S
(int) k
( contextLength;) p n
() S 8 T () S 16 T () S 24 T () N
() S 8 T () S 16 T () S 24 T (replWithContextFiles\(walk, new, &newLen, newsize, &conte) N
(xtLength\);) N
() S 8 T () S 16 T () S 24 T (walk += contextLength;) N
() S 8 T () S 16 T (} ) S 24 T () N
() S 8 T () S 16 T () S
(else) K
({) p n
(expand.c) (Page 5/6) (May 08, 14 22:34) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p 8 T (        strncpy\(&new[newLen], walk, 1\); ) S
(//Copy over *) c n
() p 8 T (        newLen++;) N
() S 8 T () S 16 T (}) N
() S 8 T () S 16 T (walk++;) N
() S 8 T (}) N
() S 8 T () S
(else) K
( ) p
(if) K
( \(c == ') p
(\\\\) str
('\){) p n
() S 8 T () S 16 T () S
(if) K
( \(*\(walk+1\) == ') p
(*) str
('\){) p n
() S 8 T (        strncpy\(&new[newLen], walk+1, 1\); ) N
() S 8 T (        newLen++;) N
() S 8 T (        walk+=2;) N
() S 8 T () S 16 T (}) N
() S 8 T (}) N
(    ) S
(else) K
({ ) p
(//Not a special character) c n
(      strncpy\(&new[newLen], walk, 1\); ) p
(//Copy over one character) c n
(      newLen++;) p n
(      walk++;) N
(    }) N
(  }) N
(  new[newLen] = 0;) N
(  ) S
(return) K
( 1;) p n
(}) N
(expand.c) (Page 6/6) (May 08, 14 22:34) title
border
grestore
(Printed by Zachary Quinn Evans) rhead
(expand.c) (8/14) (Friday May 09, 2014) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1-2) 9
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* CS 352 -- Mini Shell!) c n
( *  $Id: msh.c,v 1.14 2014/05/07 09:47:36 evansz2 Exp $) N
( *  Starting code: Phil Nelson) N
( *  Zach Evans) N
( *  CSCI 352) N
( *  Spring 2014) N
( */) N
() p n
(#include) K
( <stdio.h>) p n
(#include) K
( <string.h>) p n
(#include) K
( <unistd.h>) p n
(#include) K
( <errno.h>) p n
(#include) K
( <stdlib.h>) p n
(#include) K
( <sys/types.h>) p n
(#include) K
( <sys/wait.h>) p n
(#include) K
( ") p
(proto.h) str
(") p n
() N
(int) k
( mainargc;) p n
(char) k
( **mainargv;) p n
(int) k
( shiftIndex;) p n
(int) k
( lastExit;) p n
(int) k
( interactive;) p n
(/* Constants */) c n
() p n
(FILE) k
( *inFile;) p n
(FILE) k
( *outFile;) p n
(FILE) k
( *errFile;) p n
() N
(/* Prototypes */) c n
() p n
(void) k
( processline \() p
(char) k
( *line\);) p n
() N
(/* Shell main */) c n
() p n
(int) k n
(main \() p
(int) k
( argc, ) p
(char) k
( **argv\)) p n
({) N
(    ) S
(char) k
(   buffer [LINELEN];) p n
(    ) S
(int) k
(    len;) p n
(    interactive = 1;) N
(    mainargc = argc;) N
(    mainargv = argv;) N
(    outFile = stdout;) N
(    errFile = stderr;) N
(    shiftIndex = 0;) N
(    lastExit = 0;) N
() N
(    ) S
(if) K
( \(argc == 1\){) p n
(      inFile = stdin;) N
(    }) N
() N
(    ) S
(else) K
( ) p
(if) K
(\(argc >= 2\){) p n
(      interactive = 0;) N
(      inFile = fopen\(mainargv[1], ") S
(r) str
("\);) p n
(      ) S
(if) K
( \(inFile == ) p
(NULL) K
(\){) p n
(        fprintf\(errFile, ") S
(Couldn't open file: %s\\n) str
(", mainargv[1]\);) p n
(        exit\(127\);) N
(      }) N
(    }) N
() N
() N
() N
(  ) S
(while) K
( \(1\) {) p n
() N
() N
(        ) S
(/* prompt and get line */) c n
(  ) p
(if) K
( \(interactive\){) p n
() S 8 T (   fprintf \(errFile, ") S
(%% ) str
("\);) p n
(   }) N
(msh.c) (Page 1/3) (May 08, 14 22:34) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p 8 T () S
(if) K
( \(fgets \(buffer, LINELEN, inFile\) != buffer\)) p n
() S 8 T (  ) S
(break) K
(;) p n
() N
(        ) S
(/* Get rid of \\n at end of buffer. */) c n
() p 8 T (len = strlen\(buffer\);) N
() S 8 T () S
(if) K
( \(buffer[len-1] == ') p
(\\n) str
('\)) p n
() S 8 T (    buffer[len-1] = 0;) N
() N
() S 8 T () S
(/* Run it ... */) c n
() p 8 T (processline \(buffer\);) N
() N
(    }) N
() N
(    ) S
(if) K
( \(!feof\(inFile\)\)) p n
(        perror \(") S
(read) str
("\);) p n
() N
(    ) S
(return) K
( 0;) p 16 T () S 24 T () S
(/* Also known as exit \(0\); */) c n
(}) p n
() N
(void) k
( processline \() p
(char) k
( *line\)) p n
({) N
(    pid_t  cpid; ) S
(//Child pid) c n
(    ) p
(int) k
(    status; ) p
(//argument for the wait\(\) function) c n
(    ) p
(int) k
( bi; ) p
(//Int to see if builtin command was run) c n
() p 8 T (  ) S
(char) k
( ** lineArgs; ) p
(//array of arguments to the line) c n
(    ) p
(char) k
( expanded[LINELEN];) p n
(    memset\(expanded, 0, LINELEN\); ) S
(//Zero out expanded) c n
(    ) p
(int) k
( expandCheck = expand\(line, expanded, LINELEN\);) p n
(    ) S
(if) K
( \(expandCheck < 0\){) p n
(      ) S
(return) K
(;) p n
(    }) N
(    ) S
(int) k
( numArgs = arg_parse\(expanded, &lineArgs\);) p n
(    ) S
(if) K
( \(numArgs < 0\){) p n
(      ) S
(return) K
(;) p n
(    }) N
(    ) S
(else) K
( ) p
(if) K
(\(numArgs == 0\){ ) p
(//If there are zero arguments, don't process the line) c n
(      free\(lineArgs\);) p n
(      ) S
(return) K
(;) p n
(    }) N
() N
() N
(    bi = runBuiltin\(numArgs, lineArgs\);) N
(    ) S
(if) K
( \(bi\){ ) p
(//Command was a builtin command) c n
(      free\(lineArgs\);) p n
(      ) S
(return) K
(;) p n
(    }) N
() N
(    ) S
(/* Start a new process to do the job. */) c n
(    cpid = fork\(\);) p n
(    ) S
(if) K
( \(cpid < 0\) {) p n
(      perror \(") S
(fork) str
("\);) p n
() S 8 T (    free\(lineArgs\);) N
(      ) S
(return) K
(;) p n
(    }) N
() N
(    ) S
(/* Check for who we are! */) c n
(    ) p
(if) K
( \(cpid == 0\) {) p n
(      ) S
(/* We are the child! */) c n
(      execvp\(lineArgs[0], lineArgs\);) p n
(      perror \(") S
(exec) str
("\);) p n
() S 8 T (  free\(lineArgs\);) N
(      exit \(127\);) N
(    }) N
(    ) S
(else) K
({) p n
(    ) S 8 T (free\(lineArgs\);) N
(    }) N
() N
(    ) S
(/* Have the parent wait for child to complete */) c n
(    ) p
(if) K
( \(wait \(&status\) < 0\)) p n
(msh.c) (Page 2/3) (May 08, 14 22:34) title
border
grestore
(Printed by Zachary Quinn Evans) rhead
(msh.c) (9/14) (Friday May 09, 2014) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (3) 10
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(      perror \(") p
(wait) str
("\);) p n
() S 8 T () N
() S 8 T () S
(if) K
( \(WIFEXITED\(status\)\){) p n
() S 8 T () S 16 T (lastExit = WEXITSTATUS\(status\);) N
() S 8 T (}) N
() S 8 T () S
(else) K
({) p n
() S 8 T () S 16 T (lastExit = 127;) N
() S 8 T (}) N
(}) N
(msh.c) (Page 3/3) (May 08, 14 22:34) title
border
grestore
(Printed by Zachary Quinn Evans) rhead
(msh.c) (10/14) (Friday May 09, 2014) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1) 11
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* CS 352 -- Function prototypes) c n
( * $Id: proto.h,v 1.7 2014/05/07 09:13:02 evansz2 Exp $) N
( *  Zach Evans) N
( *  CSCI 352) N
( *  Spring 2014) N
( */) N
(#include) K
( <stdio.h>) p n
(#define) K
( LINELEN 1024) p n
() N
(int) k
( arg_parse\() p
(char) k
( *line, ) p
(char) k
( ***argvp\);) p n
(int) k
( runBuiltin\() p
(int) k
( argc, ) p
(char) k
( **argv\);) p n
(int) k
( expand \() p
(char) k
( *orig, ) p
(char) k
( *new, ) p
(int) k
( newsize\);) p n
() N
() N
(extern) K
( ) p
(int) k
( mainargc;) p n
(extern) K
( ) p
(char) k
( **mainargv;) p n
(extern) K
( ) p
(FILE) k
( *inFile;) p n
(extern) K
( ) p
(FILE) k
( *outFile;) p n
(extern) K
( ) p
(int) k
( shiftIndex;) p n
(extern) K
( ) p
(int) k
( lastExit;) p n
(extern) K
( ) p
(int) k
( interactive;) p
(proto.h) (Page 1/1) (May 08, 14 22:34) title
border
grestore
(Printed by Zachary Quinn Evans) rhead
(proto.h) (11/14) (Friday May 09, 2014) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1-2) 12
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(Script started on Fri 09 May 2014 01:58:35 AM PDT) p n
(evansz2@linux-08:~/cs352s14/dev/msh$ cd /home/phil/public/cs352/testa4) N
(evansz2@linux-08:/home/phil/public/cs352/testa4$ ls) N
(d) S 8 T (doexit.c  scr1) S 24 T (scr3  scr5     script2) S 48 T (secho.c  try~) N
(doexit) S 8 T (MSH.OUT   scr2) S 24 T (scr4  script1  secho) S 48 T (try) N
(evansz2@linux-08:/home/phil/public/cs352/testa4$ ./try) N
(making ...) N
(testing ... ) N
(Making REF) N
(Big script output same) N
(Doing other tests! ...) N
(Non-constant tests and error tests!) N
(Running msh scr5 a b c) N
(Dollar 1 is 'a'.) N
(Shifting by 1) N
(should NOT have been an error! Exit value is 0. Should be 0.) N
(Now Dollar 1 is 'b'.) N
() N
(Shifting by 4) N
(Shift index too high) N
(should have been an error! Exit value is 1. Should be 1.) N
(Shifting by 2) N
(should NOT have been an error! Exit value is 0. Should be 0.) N
(Now Dollar 1 is ''. \(Should be empty!\)) N
(Checking unshift) N
(should NOT have been an error! Exit value is 0. Should be 0.) N
(Shift index too high) N
(should have been an error! Exit value is 1. Should be 1.) N
() N
(Checking bad command return.) N
(exec: No such file or directory) N
(Exit value is 127. Should be 127.) N
() N
(Tests done!) N
(View INFO? n) N
(evansz2@linux-08:/home/phil/public/cs352/testa4$ cd) N
(evansz2@linux-08:~$ ls) N
(argtest      Desktop) S 24 T (     hello) S 40 T (     Templates) N
(calculator1  digitaldisplay  Music) S 40 T (     test4) N
(calculator2  Documents) S 24 T (     old_n) S 40 T (     upstart-dbus-bridge.17877.pid) N
(CS141) S 8 T (     Downloads) S 24 T (     Old Schoolwork  upstart-file-bridge.17877.pid) N
(cs352s14     filetest) S 24 T (     Pictures) S 40 T (     Videos) N
(CS402) S 8 T (     freqanal) S 24 T (     Public) S 40 T (     x) N
(CSCI367      GNUstep) S 24 T (     public_html) N
(evansz2@linux-08:~$ cd cs352s14/) N
(evansz2@linux-08:~/cs352s14$ ls) N
(a1  a2) S 8 T (CVSrep) S 16 T (dev  testing) N
(evansz2@linux-08:~/cs352s14$ cd dev/msh) N
(evansz2@linux-08:~/cs352s14/dev/msh$ ls) N
(arg_parse.c  ASSG4) S 24 T (builtin.o  expand.c  Makefile  msh.c  proto.h) N
(arg_parse.o  builtin.c) S 24 T (CVS) S 32 T (   expand.o  msh       msh.o  testScript) N
(evansz2@linux-08:~/cs352s14/dev/msh$ make) N
(make: Nothing to be done for `all'.) N
(evansz2@linux-08:~/cs352s14/dev/msh$ make clean) N
(rm *.o msh) N
(Clean done) N
(evansz2@linux-08:~/cs352s14/dev/msh$ make) N
(Making Object) N
(gcc -c -g -Wall arg_parse.c builtin.c msh.c expand.c) N
(gcc -g -Wall -o msh arg_parse.o builtin.o msh.o expand.o) N
(evansz2@linux-08:~/cs352s14/dev/msh$ ./msh testScript) N
(There are 1 arguments) N
(Script name is testScript) N
(First argument is) N
(Shifting by 1) N
(Shift index too high) N
(There are 1 arguments) N
(First argument is) N
(Unshifting) N
(ASSG4) (Page 1/2) (May 09, 14 2:00) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(First argument is) p n
(My files: testScript arg_parse.c ASSG4 builtin.o msh.o expand.o msh CVS Makefile) N
( proto.h msh.c builtin.c arg_parse.o expand.c ) N
(Now for some stats!) N
(testScript evansz2 students -rw-r--r-- 1 353 Fri May  9 01:57:09 2014) N
(arg_parse.c evansz2 students -rw-r--r-- 1 3288 Mon Apr 21 19:08:08 2014) N
(ASSG4 evansz2 students -rw-r--r-- 1 0 Fri May  9 01:58:22 2014) N
(builtin.o evansz2 students -rw-r--r-- 1 16464 Fri May  9 01:59:21 2014) N
(msh.o evansz2 students -rw-r--r-- 1 10376 Fri May  9 01:59:21 2014) N
(expand.o evansz2 students -rw-r--r-- 1 16280 Fri May  9 01:59:21 2014) N
(msh evansz2 students -rwxr-xr-x 1 35250 Fri May  9 01:59:21 2014) N
(CVS evansz2 students drwxr-xr-x 2 5 Thu May  8 22:34:41 2014) N
(Makefile evansz2 students -rw-r--r-- 1 359 Sat Apr 26 17:31:13 2014) N
(proto.h evansz2 students -rw-r--r-- 1 465 Thu May  8 22:34:41 2014) N
(msh.c evansz2 students -rw-r--r-- 1 2776 Thu May  8 22:34:41 2014) N
(builtin.c evansz2 students -rw-r--r-- 1 5946 Thu May  8 22:34:41 2014) N
(arg_parse.o evansz2 students -rw-r--r-- 1 4736 Fri May  9 01:59:21 2014) N
(expand.c evansz2 students -rw-r--r-- 1 9254 Thu May  8 22:34:41 2014) N
(Let's see how the pros do it) N
(total 137) N
(-rw-r--r-- 1 evansz2 students  3288 Apr 21 19:08 arg_parse.c) N
(-rw-r--r-- 1 evansz2 students  4736 May  9 01:59 arg_parse.o) N
(-rw-r--r-- 1 evansz2 students     0 May  9 01:58 ASSG4) N
(-rw-r--r-- 1 evansz2 students  5946 May  8 22:34 builtin.c) N
(-rw-r--r-- 1 evansz2 students 16464 May  9 01:59 builtin.o) N
(drwxr-xr-x 2 evansz2 students     5 May  8 22:34 CVS) N
(-rw-r--r-- 1 evansz2 students  9254 May  8 22:34 expand.c) N
(-rw-r--r-- 1 evansz2 students 16280 May  9 01:59 expand.o) N
(-rw-r--r-- 1 evansz2 students   359 Apr 26 17:31 Makefile) N
(-rwxr-xr-x 1 evansz2 students 35250 May  9 01:59 msh) N
(-rw-r--r-- 1 evansz2 students  2776 May  8 22:34 msh.c) N
(-rw-r--r-- 1 evansz2 students 10376 May  9 01:59 msh.o) N
(-rw-r--r-- 1 evansz2 students   465 May  8 22:34 proto.h) N
(-rw-r--r-- 1 evansz2 students   353 May  9 01:57 testScript) N
(Exit status: 0) N
(Showing .c files) N
(arg_parse.c msh.c builtin.c expand.c) N
(evansz2@linux-08:~/cs352s14/dev/msh$ ./msh) N
(% first arg ) N
(exec: No such file or directory) N
(% echo $?) N
(127) N
(% echo first arg is $\)^H ^H\)^H ^H0) N
(first arg is ./msh) N
(% exit) N
(evansz2@linux-08:~/cs352s14/dev/msh$ exit) N
(exit) N
() N
(Script done on Fri 09 May 2014 02:01:09 AM PDT) N
(ASSG4) (Page 2/2) (May 09, 14 2:00) title
border
grestore
(Printed by Zachary Quinn Evans) rhead
(ASSG4) (12/14) (Friday May 09, 2014) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1) 13
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
( ) p
(#    $Id: Makefile,v 1.3 2014/04/27 00:31:13 evansz2 Exp $) c n
() p n
(CC) l
( = gcc) p n
(CFLAGS) l
( = -g -Wall) p n
(SOURCES) l
( = arg_parse.c builtin.c msh.c expand.c) p n
(OBJECTS) l
( = $\(SOURCES:.c=.o\)) p n
() N
(all) L
(: msh) p n
() N
() N
(msh) L
(: $\(OBJECTS\)) p n
() S 8 T ($\(CC\) $\(CFLAGS\) -o msh $\(OBJECTS\)) N
() N
($\(OBJECTS\)) L
(:$\(SOURCES\)) p n
() S 8 T (@echo Making Object ) N
() S 8 T ($\(CC\) -c -g -Wall $\(SOURCES\)) N
() N
(clean) L
(:) p n
() S 8 T (rm *.o msh) N
() S 8 T (@echo Clean ) S
(done) K n
() p n
($\(SOURCES\)) L
(: proto.h) p n
(Makefile) (Page 1/1) (Apr 26, 14 17:31) title
border
grestore
(Printed by Zachary Quinn Evans) rhead
(Makefile) (13/14) (Friday May 09, 2014) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1) 14
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(echo There are $# arguments) p n
(echo Script name is $0) N
(echo First argument is $1) N
(echo Shifting by 1) N
(shift) N
(echo There are $# arguments) N
(echo First argument is $1) N
(echo Unshifting) N
(unshift) N
(echo First argument is $1) N
(echo "My files: * ") N
(echo "Now for some stats!") N
(sstat *) N
(echo Let's see how the pros do it) N
(ls -l) N
(echo Exit status: $?) N
(echo Showing .c files) N
(echo *.c) N
(testScript) (Page 1/1) (May 09, 14 1:57) title
border
grestore
(Printed by Zachary Quinn Evans) rhead
(testScript) (14/14) (Friday May 09, 2014) footer
end % of iso1dict
pagesave restore
showpage

%%Trailer
end
%%EOF
